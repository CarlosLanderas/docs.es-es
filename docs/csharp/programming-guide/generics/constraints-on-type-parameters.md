---
title: 'Restricciones de tipos de parámetros: Guía de programación de C#'
ms.custom: seodec18
ms.date: 04/12/2018
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.openlocfilehash: d05307735506db0f0e4abab067334e4f0466ee6a
ms.sourcegitcommit: 81ad1f09b93f3b3e6706a7f2e4ddf50ef229ea3d
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/20/2019
ms.locfileid: "74204636"
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="43898-102">Restricciones de tipos de parámetros (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="43898-102">Constraints on type parameters (C# Programming Guide)</span></span>

<span data-ttu-id="43898-103">Las restricciones informan al compilador sobre las capacidades que debe tener un argumento de tipo.</span><span class="sxs-lookup"><span data-stu-id="43898-103">Constraints inform the compiler about the capabilities a type argument must have.</span></span> <span data-ttu-id="43898-104">Sin restricciones, el argumento de tipo puede ser cualquier tipo.</span><span class="sxs-lookup"><span data-stu-id="43898-104">Without any constraints, the type argument could be any type.</span></span> <span data-ttu-id="43898-105">El compilador solo puede suponer los miembros de <xref:System.Object?displayProperty=nameWithType>, que es la clase base fundamental de los tipos .NET.</span><span class="sxs-lookup"><span data-stu-id="43898-105">The compiler can only assume the members of <xref:System.Object?displayProperty=nameWithType>, which is the ultimate base class for any .NET type.</span></span> <span data-ttu-id="43898-106">Para más información, vea [Por qué usar restricciones](#why-use-constraints).</span><span class="sxs-lookup"><span data-stu-id="43898-106">For more information, see [Why use constraints](#why-use-constraints).</span></span> <span data-ttu-id="43898-107">Si el código de cliente intenta crear una instancia de su clase mediante un tipo que no se permite por una restricción, el resultado es un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="43898-107">If client code tries to instantiate your class by using a type that is not allowed by a constraint, the result is a compile-time error.</span></span> <span data-ttu-id="43898-108">Las restricciones se especifican con la palabra clave contextual `where`.</span><span class="sxs-lookup"><span data-stu-id="43898-108">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="43898-109">En la tabla siguiente se muestran los siete tipos de restricciones:</span><span class="sxs-lookup"><span data-stu-id="43898-109">The following table lists the seven types of constraints:</span></span>

|<span data-ttu-id="43898-110">Restricción</span><span class="sxs-lookup"><span data-stu-id="43898-110">Constraint</span></span>|<span data-ttu-id="43898-111">DESCRIPCIÓN</span><span class="sxs-lookup"><span data-stu-id="43898-111">Description</span></span>|
|----------------|-----------------|
|`where T : struct`|<span data-ttu-id="43898-112">El argumento de tipo debe ser un tipo que no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="43898-112">The type argument must be a non-nullable value type.</span></span> <span data-ttu-id="43898-113">Para más información sobre los tipos de valor que admiten un valor NULL, consulte [Tipos de valor que admiten un valor NULL](../../language-reference/builtin-types/nullable-value-types.md).</span><span class="sxs-lookup"><span data-stu-id="43898-113">For information about nullable value types, see [Nullable value types](../../language-reference/builtin-types/nullable-value-types.md).</span></span> <span data-ttu-id="43898-114">Todos los tipos de valor tienen un constructor sin parámetros accesible, por lo que la restricción `struct` implica la restricción `new()` y no se puede combinar con la restricción `new()`.</span><span class="sxs-lookup"><span data-stu-id="43898-114">Because all value types have an accessible parameterless constructor, the `struct` constraint implies the `new()` constraint and can't be combined with the `new()` constraint.</span></span> <span data-ttu-id="43898-115">Tampoco se puede combinar la restricción `struct` con la restricción `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="43898-115">You also cannot combine the `struct` constraint with the `unmanaged` constraint.</span></span>|
|`where T : class`|<span data-ttu-id="43898-116">El argumento de tipo debe ser un tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="43898-116">The type argument must be a reference type.</span></span> <span data-ttu-id="43898-117">Esta restricción se aplica también a cualquier clase, interfaz, delegado o tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="43898-117">This constraint applies also to any class, interface, delegate, or array type.</span></span>|
|`where T : notnull`|<span data-ttu-id="43898-118">El argumento de tipo debe ser un tipo que no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="43898-118">The type argument must be a non-nullable type.</span></span> <span data-ttu-id="43898-119">El argumento puede ser un tipo de referencia que no acepta valores NULL en C# 8.0 o posterior, o un tipo de valor que no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="43898-119">The argument can be a non-nullable reference type in C# 8.0 or later, or a not nullable value type.</span></span> <span data-ttu-id="43898-120">Esta restricción se aplica también a cualquier clase, interfaz, delegado o tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="43898-120">This constraint applies also to any class, interface, delegate, or array type.</span></span>|
|`where T : unmanaged`|<span data-ttu-id="43898-121">El argumento de tipo debe ser un tipo [no administrado](../../language-reference/builtin-types/unmanaged-types.md) que no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="43898-121">The type argument must be a non-nullable [unmanaged type](../../language-reference/builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="43898-122">La restricción `unmanaged` implica la restricción `struct` y no se puede combinar con las restricciones `struct` ni `new()`.</span><span class="sxs-lookup"><span data-stu-id="43898-122">The `unmanaged` constraint implies the `struct` constraint and can't be combined with either the `struct` or `new()` constraints.</span></span>|
|`where T : new()`|<span data-ttu-id="43898-123">El argumento de tipo debe tener un constructor sin parámetros público.</span><span class="sxs-lookup"><span data-stu-id="43898-123">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="43898-124">Cuando se usa conjuntamente con otras restricciones, la restricción `new()` debe especificarse en último lugar.</span><span class="sxs-lookup"><span data-stu-id="43898-124">When used together with other constraints, the `new()` constraint must be specified last.</span></span> <span data-ttu-id="43898-125">La restricción `new()` no se puede combinar con las restricciones `struct` ni `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="43898-125">The `new()` constraint can't be combined with the `struct` and `unmanaged` constraints.</span></span>|
|<span data-ttu-id="43898-126">`where T :` *\<nombre de clase base>*</span><span class="sxs-lookup"><span data-stu-id="43898-126">`where T :` *\<base class name>*</span></span>|<span data-ttu-id="43898-127">El argumento de tipo debe ser o derivarse de la clase base especificada.</span><span class="sxs-lookup"><span data-stu-id="43898-127">The type argument must be or derive from the specified base class.</span></span>|
|<span data-ttu-id="43898-128">`where T :` *\<nombre de interfaz>*</span><span class="sxs-lookup"><span data-stu-id="43898-128">`where T :` *\<interface name>*</span></span>|<span data-ttu-id="43898-129">El argumento de tipo debe ser o implementar la interfaz especificada.</span><span class="sxs-lookup"><span data-stu-id="43898-129">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="43898-130">Pueden especificarse varias restricciones de interfaz.</span><span class="sxs-lookup"><span data-stu-id="43898-130">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="43898-131">La interfaz de restricciones también puede ser genérica.</span><span class="sxs-lookup"><span data-stu-id="43898-131">The constraining interface can also be generic.</span></span>|
|`where T : U`|<span data-ttu-id="43898-132">El argumento de tipo proporcionado por T debe ser o derivarse del argumento proporcionado para U.</span><span class="sxs-lookup"><span data-stu-id="43898-132">The type argument supplied for T must be or derive from the argument supplied for U.</span></span>|

## <a name="why-use-constraints"></a><span data-ttu-id="43898-133">Por qué usar restricciones</span><span class="sxs-lookup"><span data-stu-id="43898-133">Why use constraints</span></span>

<span data-ttu-id="43898-134">Al restringir el parámetro de tipo, aumenta el número de operaciones y llamadas al método permitidas a las que se admiten mediante el tipo de restricción y todos los tipos en su jerarquía de herencia.</span><span class="sxs-lookup"><span data-stu-id="43898-134">By constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all types in its inheritance hierarchy.</span></span> <span data-ttu-id="43898-135">Cuando se diseñan clases o métodos genéricos, si se va a realizar una operación en los miembros genéricos más allá de una asignación simple o una llamada a un método que <xref:System.Object?displayProperty=nameWithType> no admita, será necesario aplicar restricciones al parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="43898-135">When you design generic classes or methods, if you'll be performing any operation on the generic members beyond simple assignment or calling any methods not supported by <xref:System.Object?displayProperty=nameWithType>, you'll have to apply constraints to the type parameter.</span></span> <span data-ttu-id="43898-136">Por ejemplo, la restricción de clase base indica al compilador que solo los objetos de este tipo o derivados de este tipo se usarán como argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="43898-136">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="43898-137">Una vez que el compilador tenga esta garantía, puede permitir que los métodos de ese tipo se llamen en la clase genérica.</span><span class="sxs-lookup"><span data-stu-id="43898-137">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="43898-138">En el ejemplo de código siguiente se muestran las funciones que podemos agregar a la clase `GenericList<T>` (en [Introducción a los genéricos](../../../standard/generics/index.md)) mediante la aplicación de una restricción de clase base.</span><span class="sxs-lookup"><span data-stu-id="43898-138">The following code example demonstrates the functionality you can add to the `GenericList<T>` class (in [Introduction to Generics](../../../standard/generics/index.md)) by applying a base class constraint.</span></span>

[!code-csharp[using the class and struct constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#9)]

<span data-ttu-id="43898-139">La restricción permite que la clase genérica use la propiedad `Employee.Name`.</span><span class="sxs-lookup"><span data-stu-id="43898-139">The constraint enables the generic class to use the `Employee.Name` property.</span></span> <span data-ttu-id="43898-140">La restricción especifica que está garantizado que todos los elementos de tipo `T` sean un objeto `Employee` u objeto que hereda de `Employee`.</span><span class="sxs-lookup"><span data-stu-id="43898-140">The constraint specifies that all items of type `T` are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>

<span data-ttu-id="43898-141">Pueden aplicarse varias restricciones en el mismo parámetro de tipo, y las propias restricciones pueden ser tipos genéricos, de la manera siguiente:</span><span class="sxs-lookup"><span data-stu-id="43898-141">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>

[!code-csharp[using the class and struct constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#10)]

<span data-ttu-id="43898-142">Al aplicar la restricción `where T : class`, evite los operadores `==` y `!=` en el parámetro de tipo porque estos operadores se probarán solo para la identidad de referencia, no para la igualdad de valor.</span><span class="sxs-lookup"><span data-stu-id="43898-142">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="43898-143">Este comportamiento se produce incluso si estos operadores están sobrecargados en un tipo que se usa como un argumento.</span><span class="sxs-lookup"><span data-stu-id="43898-143">This behavior occurs even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="43898-144">En el código siguiente se ilustra este punto; el resultado es False incluso cuando la clase <xref:System.String> sobrecarga al operador `==`.</span><span class="sxs-lookup"><span data-stu-id="43898-144">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>

[!code-csharp[using the class and struct constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#11)]

<span data-ttu-id="43898-145">El compilador solo sabe que `T` es un tipo de referencia en tiempo de compilación y debe usar los operadores predeterminados que son válidos para todos los tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="43898-145">The compiler only knows that `T` is a reference type at compile time and must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="43898-146">Si debe probar la igualdad de valor, la manera recomendada también es aplicar la restricción `where T : IEquatable<T>` o `where T : IComparable<T>` e implementar esa interfaz en cualquier clase que se usará para construir la clase genérica.</span><span class="sxs-lookup"><span data-stu-id="43898-146">If you must test for value equality, the recommended way is to also apply the `where T : IEquatable<T>` or `where T : IComparable<T>` constraint and implement the interface in any class that will be used to construct the generic class.</span></span>

## <a name="constraining-multiple-parameters"></a><span data-ttu-id="43898-147">Restringir varios parámetros</span><span class="sxs-lookup"><span data-stu-id="43898-147">Constraining multiple parameters</span></span>

<span data-ttu-id="43898-148">Puede aplicar restricciones a varios parámetros, y varias restricciones a un solo parámetro, como se muestra en el siguiente ejemplo:</span><span class="sxs-lookup"><span data-stu-id="43898-148">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>

[!code-csharp[using the class and struct constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#12)]

## <a name="unbounded-type-parameters"></a><span data-ttu-id="43898-149">Parámetros de tipo sin enlazar</span><span class="sxs-lookup"><span data-stu-id="43898-149">Unbounded type parameters</span></span>

 <span data-ttu-id="43898-150">Los parámetros de tipo que no tienen restricciones, como T en la clase pública `SampleClass<T>{}`, se denominan parámetros de tipo sin enlazar.</span><span class="sxs-lookup"><span data-stu-id="43898-150">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="43898-151">Los parámetros de tipo sin enlazar tienen las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="43898-151">Unbounded type parameters have the following rules:</span></span>

- <span data-ttu-id="43898-152">Los operadores `!=` y `==` no pueden usarse porque no existe ninguna garantía de que el argumento de tipo concreto admita estos operadores.</span><span class="sxs-lookup"><span data-stu-id="43898-152">The `!=` and `==` operators can't be used because there's no guarantee that the concrete type argument will support these operators.</span></span>
- <span data-ttu-id="43898-153">Pueden convertirse a y desde `System.Object` o convertirse explícitamente en cualquier tipo de interfaz.</span><span class="sxs-lookup"><span data-stu-id="43898-153">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>
- <span data-ttu-id="43898-154">Puede compararlos con [NULL](../../language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="43898-154">You can compare them to [null](../../language-reference/keywords/null.md).</span></span> <span data-ttu-id="43898-155">Si un parámetro sin enlazar se compara con `null`, la comparación siempre devolverá False si el argumento de tipo es un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="43898-155">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>

## <a name="type-parameters-as-constraints"></a><span data-ttu-id="43898-156">Parámetros de tipo como restricciones</span><span class="sxs-lookup"><span data-stu-id="43898-156">Type parameters as constraints</span></span>

<span data-ttu-id="43898-157">El uso de un parámetro de tipo genérico como una restricción es útil cuando una función de miembro con su propio parámetro de tipo tiene que restringir ese parámetro al parámetro de tipo del tipo contenedor, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="43898-157">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>

[!code-csharp[using the class and struct constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#13)]

<span data-ttu-id="43898-158">En el ejemplo anterior, `T` es una restricción de tipo en el contexto del método `Add`, y un parámetro de tipo sin enlazar en el contexto de la clase `List`.</span><span class="sxs-lookup"><span data-stu-id="43898-158">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>

<span data-ttu-id="43898-159">Los parámetros de tipo también pueden usarse como restricciones en definiciones de clase genéricas.</span><span class="sxs-lookup"><span data-stu-id="43898-159">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="43898-160">El parámetro de tipo debe declararse dentro de los corchetes angulares junto con los demás parámetros de tipo:</span><span class="sxs-lookup"><span data-stu-id="43898-160">The type parameter must be declared within the angle brackets together with any other type parameters:</span></span>

[!code-csharp[using the class and struct constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#14)]

<span data-ttu-id="43898-161">La utilidad de los parámetros de tipo como restricciones con clases genéricas es limitada, ya que el compilador no puede dar por supuesto nada sobre el parámetro de tipo, excepto que deriva de `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="43898-161">The usefulness of type parameters as constraints with generic classes is limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="43898-162">Use parámetros de tipo como restricciones en clases genéricas en escenarios en los que quiere aplicar una relación de herencia entre dos parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="43898-162">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>

## <a name="notnull-constraint"></a><span data-ttu-id="43898-163">Restricción NotNull</span><span class="sxs-lookup"><span data-stu-id="43898-163">NotNull constraint</span></span>

<span data-ttu-id="43898-164">A partir C# 8.0, puede usar la restricción `notnull` para especificar que el argumento de tipo debe ser un tipo de valor que no acepta valores NULL o un tipo de referencia que no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="43898-164">Beginning with C# 8.0, you can use the `notnull` constraint to specify that the type argument must be a non-nullable value type or non-nullable reference type.</span></span> <span data-ttu-id="43898-165">La restricción `notnull` solo se puede usar en un contexto `nullable enable`.</span><span class="sxs-lookup"><span data-stu-id="43898-165">The `notnull` constraint can only be used in a `nullable enable` context.</span></span> <span data-ttu-id="43898-166">El compilador genera una advertencia si se agrega una restricción `notnull` en un contexto donde se desconoce que se aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="43898-166">The compiler generates a warning if you add the `notnull` constraint in a nullable oblivious context.</span></span> 

<span data-ttu-id="43898-167">A diferencia de otras restricciones, cuando un argumento de tipo infringe la restricción `notnull`, el compilador genera una advertencia cuando el código se compila en un contexto `nullable enable`.</span><span class="sxs-lookup"><span data-stu-id="43898-167">Unlike other constraints, when a type argument violates the `notnull` constraint, the compiler generates a warning when that code is compiled in a `nullable enable` context.</span></span> <span data-ttu-id="43898-168">Si el código se compila en un contexto donde se desconoce que se aceptan valores NULL, el compilador no genera ninguna advertencia o error.</span><span class="sxs-lookup"><span data-stu-id="43898-168">If the code is compiled in a nullable oblivious context, the compiler doesn't generate any warnings or errors.</span></span>

## <a name="unmanaged-constraint"></a><span data-ttu-id="43898-169">Restricción no administrada</span><span class="sxs-lookup"><span data-stu-id="43898-169">Unmanaged constraint</span></span>

<span data-ttu-id="43898-170">A partir de C# 7.3, puede usar la restricción `unmanaged` para especificar que el parámetro de tipo debe ser un [tipo no administrado](../../language-reference/builtin-types/unmanaged-types.md) que no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="43898-170">Beginning with C# 7.3, you can use the `unmanaged` constraint to specify that the type parameter must be a non-nullable [unmanaged type](../../language-reference/builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="43898-171">La restricción `unmanaged` permite escribir rutinas reutilizables para trabajar con tipos que se pueden manipular como bloques de memoria, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="43898-171">The `unmanaged` constraint enables you to write reusable routines to work with types that can be manipulated as blocks of memory, as shown in the following example:</span></span>

[!code-csharp[using the unmanaged constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#15)]

<span data-ttu-id="43898-172">El método anterior debe compilarse en un contexto `unsafe`, ya que usa el operador `sizeof` en un tipo que se desconoce si es integrado.</span><span class="sxs-lookup"><span data-stu-id="43898-172">The preceding method must be compiled in an `unsafe` context because it uses the `sizeof` operator on a type not known to be a built-in type.</span></span> <span data-ttu-id="43898-173">Sin la restricción `unmanaged`, el operador `sizeof` no está disponible.</span><span class="sxs-lookup"><span data-stu-id="43898-173">Without the `unmanaged` constraint, the `sizeof` operator is unavailable.</span></span>

<span data-ttu-id="43898-174">La restricción `unmanaged` implica la restricción `struct` y no se puede combinar con ella.</span><span class="sxs-lookup"><span data-stu-id="43898-174">The `unmanaged` constraint implies the `struct` constraint and can't be combined with it.</span></span> <span data-ttu-id="43898-175">Dado que la restricción `struct` implica la restricción `new()`, la restricción `unmanaged` tampoco se puede combinar con la restricción `new()`.</span><span class="sxs-lookup"><span data-stu-id="43898-175">Because the `struct` constraint implies the `new()` constraint, the `unmanaged` constraint can't be combined with the `new()` constraint as well.</span></span>

## <a name="delegate-constraints"></a><span data-ttu-id="43898-176">Restricciones de delegado</span><span class="sxs-lookup"><span data-stu-id="43898-176">Delegate constraints</span></span>

<span data-ttu-id="43898-177">También a partir de C# 7.3, puede usar <xref:System.Delegate?displayProperty=nameWithType> o <xref:System.MulticastDelegate?displayProperty=nameWithType> como una restricción de clase base.</span><span class="sxs-lookup"><span data-stu-id="43898-177">Also beginning with C# 7.3, you can use <xref:System.Delegate?displayProperty=nameWithType> or <xref:System.MulticastDelegate?displayProperty=nameWithType> as a base class constraint.</span></span> <span data-ttu-id="43898-178">CLR siempre permitía esta restricción, pero el lenguaje C# no la permitía.</span><span class="sxs-lookup"><span data-stu-id="43898-178">The CLR always allowed this constraint, but the C# language disallowed it.</span></span> <span data-ttu-id="43898-179">La restricción `System.Delegate` permite escribir código que funciona con los delegados en un modo con seguridad de tipos.</span><span class="sxs-lookup"><span data-stu-id="43898-179">The `System.Delegate` constraint enables you to write code that works with delegates in a type-safe manner.</span></span> <span data-ttu-id="43898-180">En el código siguiente se define un método de extensión que combina dos delegados siempre y cuando sean del mismo tipo:</span><span class="sxs-lookup"><span data-stu-id="43898-180">The following code defines an extension method that combines two delegates provided they're the same type:</span></span>

[!code-csharp[using the delegate constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#16)]

<span data-ttu-id="43898-181">Puede usar el método anterior para combinar delegados que sean del mismo tipo:</span><span class="sxs-lookup"><span data-stu-id="43898-181">You can use the above method to combine delegates that are the same type:</span></span>

[!code-csharp[using the unmanaged constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#17)]

<span data-ttu-id="43898-182">Si quita la marca de comentario de la última línea, no se compilará.</span><span class="sxs-lookup"><span data-stu-id="43898-182">If you uncomment the last line, it won't compile.</span></span> <span data-ttu-id="43898-183">Tanto `first` como `test` son tipos de delegado, pero son tipos de delegado distintos.</span><span class="sxs-lookup"><span data-stu-id="43898-183">Both `first` and `test` are delegate types, but they're different delegate types.</span></span>

## <a name="enum-constraints"></a><span data-ttu-id="43898-184">Restricciones de enumeración</span><span class="sxs-lookup"><span data-stu-id="43898-184">Enum constraints</span></span>

<span data-ttu-id="43898-185">A partir de C# 7.3, también puede especificar el tipo <xref:System.Enum?displayProperty=nameWithType> como una restricción de clase base.</span><span class="sxs-lookup"><span data-stu-id="43898-185">Beginning in C# 7.3, you can also specify the <xref:System.Enum?displayProperty=nameWithType> type as a base class constraint.</span></span> <span data-ttu-id="43898-186">CLR siempre permitía esta restricción, pero el lenguaje C# no la permitía.</span><span class="sxs-lookup"><span data-stu-id="43898-186">The CLR always allowed this constraint, but the C# language disallowed it.</span></span> <span data-ttu-id="43898-187">Los genéricos que usan `System.Enum` proporcionan programación con seguridad de tipos para almacenar en caché los resultados de usar los métodos estáticos en `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="43898-187">Generics using `System.Enum` provide type-safe programming to cache results from using the static methods in `System.Enum`.</span></span> <span data-ttu-id="43898-188">En el ejemplo siguiente se buscan todos los valores válidos para un tipo de enumeración y, después, se compila un diccionario que asigna esos valores a su representación de cadena.</span><span class="sxs-lookup"><span data-stu-id="43898-188">The following sample finds all the valid values for an enum type, and then builds a dictionary that maps those values to its string representation.</span></span>

[!code-csharp[using the unmanaged constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#18)]

<span data-ttu-id="43898-189">Los métodos empleados usan reflexión, lo que tiene consecuencias en el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="43898-189">The methods used make use of reflection, which has performance implications.</span></span> <span data-ttu-id="43898-190">Puede llamar a este método para compilar una recopilación que se almacene en caché y se vuelva a usar, en lugar de repetir las llamadas que requieren reflexión.</span><span class="sxs-lookup"><span data-stu-id="43898-190">You can call this method to build a collection that is cached and reused rather than repeating the calls that require reflection.</span></span>

<span data-ttu-id="43898-191">Podría usarla como se muestra en el ejemplo siguiente para crear una enumeración y compilar un diccionario con sus nombres y valores:</span><span class="sxs-lookup"><span data-stu-id="43898-191">You could use it as shown in the following sample to create an enum and build a dictionary of its values and names:</span></span>

[!code-csharp[using the unmanaged constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#19)]

[!code-csharp[using the unmanaged constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#20)]

## <a name="see-also"></a><span data-ttu-id="43898-192">Vea también</span><span class="sxs-lookup"><span data-stu-id="43898-192">See also</span></span>

- <xref:System.Collections.Generic>
- [<span data-ttu-id="43898-193">Guía de programación de C#</span><span class="sxs-lookup"><span data-stu-id="43898-193">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="43898-194">Introducción a los genéricos</span><span class="sxs-lookup"><span data-stu-id="43898-194">Introduction to Generics</span></span>](./index.md)
- [<span data-ttu-id="43898-195">Clases genéricas</span><span class="sxs-lookup"><span data-stu-id="43898-195">Generic Classes</span></span>](./generic-classes.md)
- [<span data-ttu-id="43898-196">new (restricción)</span><span class="sxs-lookup"><span data-stu-id="43898-196">new Constraint</span></span>](../../language-reference/keywords/new-constraint.md)
