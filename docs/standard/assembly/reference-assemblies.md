---
title: Ensamblados de referencia
description: Obtenga información sobre los ensamblados de referencia, un tipo especial de ensamblados de .NET que contienen solo la superficie de la API pública de la biblioteca.
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: c38f208c2daac914176bbeedbde9e69fd68f55c6
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/07/2019
ms.locfileid: "73740484"
---
# <a name="reference-assemblies"></a><span data-ttu-id="7b31e-103">Ensamblados de referencia</span><span class="sxs-lookup"><span data-stu-id="7b31e-103">Reference assemblies</span></span>

<span data-ttu-id="7b31e-104">*Los ensamblados de referencia*  son un tipo especial de ensamblado que contiene solo la cantidad mínima de metadatos necesarios para representar la superficie de la API pública de la biblioteca.</span><span class="sxs-lookup"><span data-stu-id="7b31e-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="7b31e-105">Incluyen declaraciones para todos los miembros que son significativos al hacer referencia a un ensamblado en las herramientas de compilación (de ahí el nombre), pero excluyen todas las implementaciones de miembros, así como las declaraciones de miembros privados que no tienen ningún impacto observable en su contrato de API.</span><span class="sxs-lookup"><span data-stu-id="7b31e-105">They include declarations for all members that are significant when referencing an assembly in build tools (hence the name), but exclude all member implementations as well as declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="7b31e-106">En cambio, los ensamblados normales se denominan *ensamblados de implementación*.</span><span class="sxs-lookup"><span data-stu-id="7b31e-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="7b31e-107">Los ensamblados de referencia no se pueden cargar para su ejecución, pero se pueden pasar como entrada del compilador de la misma manera que los ensamblados de implementación.</span><span class="sxs-lookup"><span data-stu-id="7b31e-107">Reference assemblies cannot be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="7b31e-108">Los ensamblados de referencia suelen distribuirse con el kit de desarrollo de software (SDK) de una plataforma o biblioteca determinada, un componente de software especial instalado solo en las máquinas de los desarrolladores.</span><span class="sxs-lookup"><span data-stu-id="7b31e-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library, a special software component installed only on developer machines.</span></span>

<span data-ttu-id="7b31e-109">El uso de un ensamblado de referencia permite a los desarrolladores compilar programas que tienen como destino una versión de biblioteca específica sin tener el ensamblado de implementación completo para esa versión.</span><span class="sxs-lookup"><span data-stu-id="7b31e-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="7b31e-110">Supongamos que solo tiene la versión más reciente de alguna biblioteca en el equipo, pero quiere compilar un programa que tenga como destino una máquina con una versión anterior de dicha biblioteca.</span><span class="sxs-lookup"><span data-stu-id="7b31e-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets a machine with an earlier version of that library.</span></span> <span data-ttu-id="7b31e-111">Si compila directamente en el ensamblado de implementación, podría usar accidentalmente miembros de la API que no están disponibles en la versión anterior, y solo se daría cuenta del error al probar el programa en la máquina de destino.</span><span class="sxs-lookup"><span data-stu-id="7b31e-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version, and you'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="7b31e-112">Si compila con el ensamblado de referencia para la versión anterior, obtendrá inmediatamente un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="7b31e-112">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="7b31e-113">Además, un ensamblado de referencia puede representar un contrato; es decir, un conjunto de API que no se corresponde con el ensamblado de implementación concreto.</span><span class="sxs-lookup"><span data-stu-id="7b31e-113">Additionally, a reference assembly can represent a contract, that is, a set of APIs that doesn't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="7b31e-114">Este ensamblado de referencia, denominado *ensamblado de contrato*, se puede usar para tener como destino varias plataformas que admiten el mismo conjunto de API.</span><span class="sxs-lookup"><span data-stu-id="7b31e-114">Such reference assembly, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="7b31e-115">Por ejemplo, .NET Standard proporciona el ensamblado del contrato, *netstandard.dll*, que representa el conjunto de API comunes compartidas entre distintas plataformas .NET.</span><span class="sxs-lookup"><span data-stu-id="7b31e-115">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="7b31e-116">Las implementaciones de estas API están contenidas en ensamblados diferentes en distintas plataformas, como *mscorlib. dll*  en .NET Framework o *System.Private.CoreLib.dll* en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7b31e-116">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="7b31e-117">Una biblioteca que tiene como destino .NET Standard puede ejecutarse en todas las plataformas que admiten .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="7b31e-117">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="7b31e-118">Uso de ensamblados de referencia</span><span class="sxs-lookup"><span data-stu-id="7b31e-118">Using reference assemblies</span></span>

<span data-ttu-id="7b31e-119">Para utilizar ciertas API del proyecto, debe agregar referencias a sus ensamblados.</span><span class="sxs-lookup"><span data-stu-id="7b31e-119">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="7b31e-120">Puede agregar referencias a ensamblados de implementación directamente o a ensamblados de referencia.</span><span class="sxs-lookup"><span data-stu-id="7b31e-120">You can add references either to implementation assemblies directly or to reference assemblies.</span></span> <span data-ttu-id="7b31e-121">Es recomendable usar ensamblados de referencia siempre que estén disponibles, ya que, al hacerlo, se asegurará de que solo se usan miembros de API que se admiten en la versión de destino y que pueden usar los diseñadores de API (es decir, no se depende de los detalles de implementación).</span><span class="sxs-lookup"><span data-stu-id="7b31e-121">We strongly recommend that you use reference assemblies whenever they are available, because doing so ensures that you are using only API members that are supported in the target version and are meant to be used by API designers (in other words, not taking a dependency on implementation details).</span></span>

<span data-ttu-id="7b31e-122">Los ensamblados de referencia de las bibliotecas de .NET Framework se distribuyen con los paquetes de destino.</span><span class="sxs-lookup"><span data-stu-id="7b31e-122">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="7b31e-123">Puede obtenerlos descargando un instalador independiente o seleccionando un componente en el instalador de Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="7b31e-123">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="7b31e-124">Para más información, consulte [Instalación de .NET Framework para desarrolladores](../../framework/install/guide-for-developers.md).</span><span class="sxs-lookup"><span data-stu-id="7b31e-124">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="7b31e-125">En .NET Core y .NET Standard, los ensamblados de referencia se descargan automáticamente según sea necesario (a través de NuGet) y se hace referencia a ellos.</span><span class="sxs-lookup"><span data-stu-id="7b31e-125">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="7b31e-126">En .NET Core 3.0 y versiones posteriores, los ensamblados de referencia para la plataforma principal se encuentran en el paquete [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) (el paquete [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) se usa para las versiones anteriores a la 3.0).</span><span class="sxs-lookup"><span data-stu-id="7b31e-126">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span> <span data-ttu-id="7b31e-127">Para obtener más información, vea [Paquetes, metapaquetes y marcos de trabajo](../../core/packages.md) en la guía de .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7b31e-127">For more information, see [Packages, metapackages and frameworks](../../core/packages.md) in the .NET Core Guide.</span></span>

<span data-ttu-id="7b31e-128">Cuando se agregan referencias a ensamblados de .NET Framework en Visual Studio mediante el cuadro de diálogo **Agregar referencia**, se selecciona un ensamblado de la lista y Visual Studio busca automáticamente los ensamblados de referencia correspondientes a la versión de la plataforma de destino seleccionada en el proyecto.</span><span class="sxs-lookup"><span data-stu-id="7b31e-128">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="7b31e-129">Lo mismo se aplica a la hora de agregar referencias directamente en el proyecto de MSBuild mediante el elemento de proyecto [Reference ](/visualstudio/msbuild/common-msbuild-project-items#reference): solo tiene que especificar el nombre del ensamblado, no la ruta de acceso del archivo completa.</span><span class="sxs-lookup"><span data-stu-id="7b31e-129">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="7b31e-130">Al agregar referencias a estos ensamblados en la línea de comandos mediante la opción del compilador `-reference` ([en C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) y en [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) o mediante el método <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> en la API de Roslyn, debe especificar manualmente los archivos de ensamblado de referencia para la versión de la plataforma de destino correcta.</span><span class="sxs-lookup"><span data-stu-id="7b31e-130">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="7b31e-131">Los archivos de ensamblado de referencia de .NET Framework se encuentran en el directorio *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework*.</span><span class="sxs-lookup"><span data-stu-id="7b31e-131">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="7b31e-132">Para .NET Core, puede forzar la operación de publicación para copiar los ensamblados de referencia de la plataforma de destino en el subdirectorio *publish/refs* del directorio de salida. Para ello, establezca la propiedad de proyecto `PreserveCompilationContext` en `true`.</span><span class="sxs-lookup"><span data-stu-id="7b31e-132">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="7b31e-133">A continuación, puede pasar estos archivos de ensamblado de referencia al compilador.</span><span class="sxs-lookup"><span data-stu-id="7b31e-133">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="7b31e-134">El uso de `DependencyContext` del paquete [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) puede ayudar a localizar sus rutas de acceso.</span><span class="sxs-lookup"><span data-stu-id="7b31e-134">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="7b31e-135">Dado que no contienen ninguna implementación, no se pueden cargar ensamblados de referencia para su ejecución. Si intenta hacerlo, se producirá una excepción <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7b31e-135">Because they contain no implementation, reference assemblies cannot be loaded for execution; trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7b31e-136">Sin embargo, se pueden cargar en el contexto de solo reflexión (con el método <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>) si necesita examinar su contenido.</span><span class="sxs-lookup"><span data-stu-id="7b31e-136">However, they still can be loaded into the reflection-only context (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>) method, if you need to examine their contents.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="7b31e-137">Generar ensamblados de referencia</span><span class="sxs-lookup"><span data-stu-id="7b31e-137">Generating reference assemblies</span></span>

<span data-ttu-id="7b31e-138">La generación de ensamblados de referencia para las bibliotecas puede ser útil cuando los consumidores de la biblioteca necesitan a menudo compilar sus programas en muchas versiones diferentes de la biblioteca (es decir, cuando necesita implementar una característica similar a los paquetes de destino de .NET Framework mencionados anteriormente para su propio proyecto).</span><span class="sxs-lookup"><span data-stu-id="7b31e-138">Generating reference assemblies for your libraries can be useful when your library consumers often need to build their programs against many different versions of the library (that is, when you need to implement a feature similar to .NET Framework Targeting Packs mentioned above for your own project).</span></span> <span data-ttu-id="7b31e-139">La distribución de los ensamblados de implementación para todas estas versiones puede no resultar práctica debido a su gran tamaño.</span><span class="sxs-lookup"><span data-stu-id="7b31e-139">Distributing implementation assemblies for all these versions might be impractical due to their large size.</span></span> <span data-ttu-id="7b31e-140">Los ensamblados de referencia tienen un tamaño menor, por lo que distribuirlos como parte del SDK de la biblioteca reduce el tamaño de la descarga y ahorra espacio en disco.</span><span class="sxs-lookup"><span data-stu-id="7b31e-140">Reference assemblies are smaller in size, so distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="7b31e-141">Los IDE y las herramientas de compilación también pueden aprovechar los ensamblados de referencia para reducir los tiempos de compilación en el caso de soluciones de gran tamaño que se componen de varias bibliotecas de clases.</span><span class="sxs-lookup"><span data-stu-id="7b31e-141">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="7b31e-142">Normalmente, en escenarios de compilación incremental, se vuelve a generar un proyecto cuando se modifica cualquiera de sus archivos de entrada, incluidos los ensamblados de los que depende.</span><span class="sxs-lookup"><span data-stu-id="7b31e-142">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="7b31e-143">El ensamblado de implementación cambia cada vez que el programador cambia la implementación de cualquier miembro.</span><span class="sxs-lookup"><span data-stu-id="7b31e-143">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="7b31e-144">El ensamblado de referencia solo cambia cuando se ve afectada su API pública.</span><span class="sxs-lookup"><span data-stu-id="7b31e-144">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="7b31e-145">Por lo tanto, el uso del ensamblado de referencia como archivo de entrada en lugar del ensamblado de implementación permite omitir la compilación del proyecto dependiente en algunos casos.</span><span class="sxs-lookup"><span data-stu-id="7b31e-145">Therefore, using the reference assembly as an input file instead of the implementation assembly allows to skip the build of the dependent project in some cases.</span></span>

<span data-ttu-id="7b31e-146">Puede generar ensamblados de referencia:</span><span class="sxs-lookup"><span data-stu-id="7b31e-146">You can generate reference assemblies:</span></span>

- <span data-ttu-id="7b31e-147">En un proyecto de MSBuild, mediante la propiedad de proyecto [ `ProduceReferenceAssembly`](/visualstudio/msbuild/common-msbuild-project-properties).</span><span class="sxs-lookup"><span data-stu-id="7b31e-147">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="7b31e-148">Al compilar el programa desde la línea de comandos, especificando las opciones de compilador `-refonly` ([en C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md), [en Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) o `-refout` ([en C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md), [en Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)).</span><span class="sxs-lookup"><span data-stu-id="7b31e-148">When compiling program from command line, by specifiying `-refonly` ([in C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md), [in Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([in C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md), [in Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="7b31e-149">Al usar la API de Roslyn, estableciendo <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> en `true` y <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> en `false` en un objeto que se pasa al método <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7b31e-149">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="7b31e-150">Si quiere distribuir ensamblados de referencia con paquetes NuGet, debe incluirlos en el subdirectorio *ref \\* del directorio del paquete, en lugar de en el subdirectorio *lib \\* que se usa para los ensamblados de implementación.</span><span class="sxs-lookup"><span data-stu-id="7b31e-150">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="7b31e-151">Estructura de ensamblados de referencia</span><span class="sxs-lookup"><span data-stu-id="7b31e-151">Reference assemblies structure</span></span>

<span data-ttu-id="7b31e-152">Los ensamblados de referencia son una expansión del concepto relacionado: los *ensamblados de solo metadatos*.</span><span class="sxs-lookup"><span data-stu-id="7b31e-152">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="7b31e-153">Los ensamblados de solo metadatos tienen sus cuerpos de métodos reemplazados por un cuerpo `throw null` único, pero incluyen todos los miembros excepto los tipos anónimos.</span><span class="sxs-lookup"><span data-stu-id="7b31e-153">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="7b31e-154">El motivo de usar cuerpos `throw null` (en lugar de no usar ningún cuerpo) es que PEVerify pueda ejecutar y pasar (y, por lo tanto, validar la integridad de los metadatos).</span><span class="sxs-lookup"><span data-stu-id="7b31e-154">The reason for using `throw null` bodies (as opposed to no bodies) is so that PEVerify can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="7b31e-155">Los ensamblados de referencia también quitan los metadatos (miembros privados) de los ensamblados de solo metadatos:</span><span class="sxs-lookup"><span data-stu-id="7b31e-155">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="7b31e-156">Un ensamblado de referencia solo tiene referencias para lo que necesita en la superficie de la API.</span><span class="sxs-lookup"><span data-stu-id="7b31e-156">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="7b31e-157">El ensamblado real puede tener referencias adicionales relacionadas con las implementaciones específicas.</span><span class="sxs-lookup"><span data-stu-id="7b31e-157">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="7b31e-158">Por ejemplo, el ensamblado de referencia de `class C { private void M() { dynamic d = 1; ... } }` no hace referencia a ningún tipo necesario para `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="7b31e-158">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` does not reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="7b31e-159">Los miembros de función privados (métodos, propiedades y eventos) se quitan en los casos donde su retirada no afecta a la compilación de manera visible.</span><span class="sxs-lookup"><span data-stu-id="7b31e-159">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="7b31e-160">Si no hay ningún atributo [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute), también se quitan los miembros de función internos.</span><span class="sxs-lookup"><span data-stu-id="7b31e-160">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="7b31e-161">Los metadatos de los ensamblados de referencia continúan conservando información sobre lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="7b31e-161">The metadata in reference assemblies continues to retain information about the following:</span></span>

- <span data-ttu-id="7b31e-162">Todos los tipos, incluidos los tipos privados y anidados.</span><span class="sxs-lookup"><span data-stu-id="7b31e-162">All types, including private and nested types.</span></span>
- <span data-ttu-id="7b31e-163">Se conservan todos los atributos (incluso los internos).</span><span class="sxs-lookup"><span data-stu-id="7b31e-163">All attributes, even internal ones.</span></span>
- <span data-ttu-id="7b31e-164">Todos los métodos virtuales.</span><span class="sxs-lookup"><span data-stu-id="7b31e-164">All virtual methods.</span></span>
- <span data-ttu-id="7b31e-165">Implementaciones de interfaz explícitas.</span><span class="sxs-lookup"><span data-stu-id="7b31e-165">Explicit interface implementations.</span></span>
- <span data-ttu-id="7b31e-166">Eventos y propiedades implementados explícitamente, ya que sus descriptores de acceso son virtuales.</span><span class="sxs-lookup"><span data-stu-id="7b31e-166">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="7b31e-167">Todos los campos de estructuras.</span><span class="sxs-lookup"><span data-stu-id="7b31e-167">All fields of structures.</span></span>

<span data-ttu-id="7b31e-168">Los ensamblados de referencia incluyen un atributo[ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) de nivel de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="7b31e-168">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="7b31e-169">Este atributo puede especificarse en el origen. En tal caso, el compilador no necesitará sintetizarlo.</span><span class="sxs-lookup"><span data-stu-id="7b31e-169">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="7b31e-170">Debido a este atributo, los tiempos de ejecución rechazarán cargar ensamblados de referencia para su ejecución (pero todavía pueden cargarse en modo de solo reflexión).</span><span class="sxs-lookup"><span data-stu-id="7b31e-170">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can still be loaded in reflection-only mode).</span></span>

<span data-ttu-id="7b31e-171">Los detalles de la estructura de ensamblado de referencia exacta dependen de la versión del compilador.</span><span class="sxs-lookup"><span data-stu-id="7b31e-171">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="7b31e-172">Las versiones más recientes pueden optar por excluir más metadatos si se determina que no afectan a la superficie de la API pública.</span><span class="sxs-lookup"><span data-stu-id="7b31e-172">Newer versions may choose to exclude more metadata if it is determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="7b31e-173">La información de esta sección solo es aplicable a los ensamblados de referencia generados por compiladores de Roslyn a partir de C# 7.1 o Visual Basic 15.3.</span><span class="sxs-lookup"><span data-stu-id="7b31e-173">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="7b31e-174">La estructura de los ensamblados de referencia para las bibliotecas de .NET Framework y .NET Core puede diferir en algunos detalles porque utilizan su propio mecanismo de generación de ensamblados de referencia.</span><span class="sxs-lookup"><span data-stu-id="7b31e-174">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="7b31e-175">Por ejemplo, podrían tener cuerpos de método totalmente vacíos en lugar del cuerpo `throw null`.</span><span class="sxs-lookup"><span data-stu-id="7b31e-175">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="7b31e-176">Pero el principio general sigue siendo aplicable: no tienen implementaciones de método que se puedan usar y contienen metadatos solo para los miembros que tienen un impacto observable desde una perspectiva de API pública.</span><span class="sxs-lookup"><span data-stu-id="7b31e-176">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="7b31e-177">Vea también</span><span class="sxs-lookup"><span data-stu-id="7b31e-177">See also</span></span>

- [<span data-ttu-id="7b31e-178">Ensamblados de .NET</span><span class="sxs-lookup"><span data-stu-id="7b31e-178">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="7b31e-179">Información general sobre destinos de Framework</span><span class="sxs-lookup"><span data-stu-id="7b31e-179">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="7b31e-180">Cómo: Adición o eliminación de referencias con el Administrador de referencias</span><span class="sxs-lookup"><span data-stu-id="7b31e-180">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
