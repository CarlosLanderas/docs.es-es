---
title: Apéndice-gRPC para desarrolladores de WCF
description: Explicación de las transacciones distribuidas y su implementación en arquitecturas de microservicios modernas.
ms.date: 09/02/2019
ms.openlocfilehash: 061aef016fd0e4303e1bbcbf0e73cec2b0c54f74
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/12/2019
ms.locfileid: "73968215"
---
# <a name="appendix-a---transactions"></a><span data-ttu-id="79a84-103">Apéndice A: transacciones</span><span class="sxs-lookup"><span data-stu-id="79a84-103">Appendix A - Transactions</span></span>

<span data-ttu-id="79a84-104">Windows Communication Foundation (WCF) admiten las transacciones distribuidas, lo que permite realizar operaciones atómicas en varios servicios.</span><span class="sxs-lookup"><span data-stu-id="79a84-104">Windows Communication Foundation (WCF) supported distributed transactions, allowing atomic operations to be performed across multiple services.</span></span> <span data-ttu-id="79a84-105">Esta funcionalidad se basó en [Microsoft Coordinador de transacciones distribuidas](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).</span><span class="sxs-lookup"><span data-stu-id="79a84-105">This functionality was based on the [Microsoft Distributed Transaction Coordinator](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).</span></span>

<span data-ttu-id="79a84-106">En el panorama moderno de microservicios, este tipo de procesamiento automatizado de transacciones distribuidas no es posible.</span><span class="sxs-lookup"><span data-stu-id="79a84-106">In the modern microservices landscape, this type of automated distributed transaction processing isn't possible.</span></span> <span data-ttu-id="79a84-107">Hay demasiadas tecnologías diferentes en juego, incluidas las bases de datos relacionales, los almacenes de datos NoSQL y los sistemas de mensajería, no para mencionar la combinación de sistemas operativos, lenguajes de programación y marcos que se pueden usar en un solo entorno.</span><span class="sxs-lookup"><span data-stu-id="79a84-107">There are too many different technologies at play, including relational databases, NoSQL data stores, and messaging systems, not to mention the mix of operating systems, programming languages and frameworks that may be used in a single environment.</span></span>

<span data-ttu-id="79a84-108">La transacción distribuida de WCF es una implementación de lo que se conoce como [confirmación en dos fases (2pc)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span><span class="sxs-lookup"><span data-stu-id="79a84-108">The WCF distributed transaction is an implementation of what is known as a [two-phase commit (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span></span> <span data-ttu-id="79a84-109">Es posible implementar transacciones de 2PC manualmente mediante la coordinación de mensajes en los servicios, la creación de transacciones abiertas dentro de cada servicio y el envío de mensajes de "confirmación" o "reversión" dependiendo de si se ha realizado correctamente o no.</span><span class="sxs-lookup"><span data-stu-id="79a84-109">It's possible to implement 2PC transactions manually by coordinating messages across services, creating open transactions within each service and sending "commit" or "rollback" messages depending upon success or failure.</span></span> <span data-ttu-id="79a84-110">Sin embargo, la complejidad implicada en la administración de 2PC puede aumentar exponencialmente a medida que los sistemas evolucionen, y las transacciones abiertas conservan bloqueos de base de datos que pueden afectar negativamente al rendimiento o, lo que es peor, causan interbloqueos entre servicios.</span><span class="sxs-lookup"><span data-stu-id="79a84-110">However, the complexity that is involved in managing 2PC can increase exponentially as systems evolve, and open transactions hold database locks that can negatively impact performance or, worse, cause cross-service deadlocks.</span></span>

<span data-ttu-id="79a84-111">Si es posible, es mejor evitar todas las transacciones distribuidas.</span><span class="sxs-lookup"><span data-stu-id="79a84-111">If possible, it's best to avoid distributed transactions altogether.</span></span> <span data-ttu-id="79a84-112">Si dos elementos de datos están vinculados como para requerir actualizaciones atómicas, considere la posibilidad de controlarlas ambos con el mismo servicio y aplicar esos cambios atómicos con una única solicitud o mensaje a ese servicio.</span><span class="sxs-lookup"><span data-stu-id="79a84-112">If two items of data are so linked as to require atomic updates, consider handling them both with the same service, and applying those atomic changes using a single request or message to that service.</span></span>

<span data-ttu-id="79a84-113">Si eso no es posible, una alternativa es usar el [patrón saga](https://microservices.io/patterns/data/saga.html).</span><span class="sxs-lookup"><span data-stu-id="79a84-113">If that isn't possible, then one alternative is to use the [Saga pattern](https://microservices.io/patterns/data/saga.html).</span></span> <span data-ttu-id="79a84-114">En un saga de actualización, las actualizaciones se procesan secuencialmente. cuando cada actualización se realiza correctamente, se desencadena la siguiente.</span><span class="sxs-lookup"><span data-stu-id="79a84-114">In a saga, updates are processing sequentially; as each update succeeds the next one is triggered.</span></span> <span data-ttu-id="79a84-115">Estos desencadenadores se pueden propagar de un servicio a otro o ser administrados por un coordinador de saga o un "orquestador".</span><span class="sxs-lookup"><span data-stu-id="79a84-115">These triggers can be propagated from service to service, or managed by a saga coordinator or "orchestrator".</span></span> <span data-ttu-id="79a84-116">Si se produce un error en una actualización en cualquier momento durante el proceso, los servicios que ya han completado sus actualizaciones aplican una lógica específica para invertirlas.</span><span class="sxs-lookup"><span data-stu-id="79a84-116">If an update fails at any point during the process, the services that have already completed their updates apply specific logic to reverse them.</span></span>

<span data-ttu-id="79a84-117">Otra opción es usar el diseño controlado por dominios (DDD) y la segregación de responsabilidad de comandos y consultas (CQRS), tal como se describe en el [libro electrónico de microservicios de .net](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/).</span><span class="sxs-lookup"><span data-stu-id="79a84-117">Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility Segregation (CQRS), as described in the [.NET Microservices e-book](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/).</span></span> <span data-ttu-id="79a84-118">En concreto, el uso de eventos de dominio o de [orígenes de eventos](https://martinfowler.com/eaaDev/EventSourcing.html) puede ayudar a garantizar que las actualizaciones sean coherentes&mdash;si no&mdash;aplican inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="79a84-118">In particular, using domain events or [event sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) can help to ensure that updates are consistently&mdash;if not immediately&mdash;applied.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="79a84-119">Anterior</span><span class="sxs-lookup"><span data-stu-id="79a84-119">Previous</span></span>](application-performance-management.md)
